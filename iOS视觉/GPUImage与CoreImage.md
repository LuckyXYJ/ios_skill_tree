## GPUImage 与 CoreImage 对比

### GPUImage

最低支持iOS4.0，iOS5.0之后就支持自定义滤镜

在低端机型上，GPUImage有更好的表现

GPUImage在视频处理上有更好的表现

GPUImage的代码完成公开，实现透明

可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高

### Core Image

官方框架，使用放心，维护方便。

支持CPU渲染，可以在后台继续处理和保存图片。

一些滤镜的性能更强劲。例如由Metal Performance Shaders 支持的模糊滤镜等

支持使用Metal 渲染图像。而Metal在iOS 平台上有更好的表现。

与Metal, SpriteKit, SceneKit, Core Animation 等更完美的配合。

支持图像识别功能。包括人脸识别、条形码识别、文本识别等。

支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一-组滤镜来改善图像效果。

支持对原生RAW格式图片的处理。

滤镜链的性能比GPUImage 高。

支持对大图进行处理，超过GPU纹理限制(4096 * 4096)的时候， 会自动拆分成几个小块处理(Automatic tiling)。GPUlmage当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。

## GPUImage特性

- 丰富的输入组件，摄像头、图片、视频、OpenGL纹理、二进制数据、UIElement（UIView， CALayer）
- 大量现成的内置滤镜
  - 颜色类（亮度、色度、饱和度、对比度、曲线、白平衡 ...）
  - 图像类（放射变换、裁剪、高斯模糊、毛玻璃效果 ...）
  - 颜色混合类（差异混合、alpha混合、遮罩混合 ...）
  - 效果类（像素化、素描效果、压花效果、球形玻璃效果 ...）
- 丰富的输出自检UIView、视频文件、GPU纹理、二进制数据
- 灵活的滤镜链。滤镜效果之间可以相互串联，并联，调用管理想当灵活
- 接口易用。滤镜和OpenGL资源的创建及使用都做了统一的封装，简单易用，并且内置了一个cache模块实现了Framebuffer的复用
- 线程管理OpenGLContext不是多线程安全的，GPUImage创建了专门的contextQueue，所有的滤镜都会扔到统一线程中处理
- 轻松实现自定义滤镜效果，继承GPUImageFulter，自动获取上面的全部特性，无需关注上下文环境搭建，专注于效果的核心算法上即可