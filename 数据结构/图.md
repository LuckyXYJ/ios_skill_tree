## å›¾

å›¾Gç”±é¡¶ç‚¹é›†Vï¼ˆvertexï¼‰å’Œè¾¹é›†Eï¼ˆedgeï¼‰ç»„æˆï¼Œé€šå¸¸è¡¨ç¤ºä¸º**G= (V, E)**

V éç©º

E å¯ä»¥ä¸ºç©º

å›¾çš„åº”ç”¨ï¼šç¤¾äº¤ç½‘ç»œï¼Œåœ°å›¾å¯¼èˆªã€‚ã€‚ã€‚

**æœ‰å‘å›¾**ï¼šè¾¹æœ‰æ˜ç¡®æ–¹å‘çš„å›¾

**æœ‰å‘æ— ç¯å›¾**ï¼šä»ä»»æ„é¡¶ç‚¹å‡ºå‘ï¼Œæ— æ³•ç»è¿‡è‹¥å¹²æ¡è¾¹å›åˆ°è¯¥é¡¶ç‚¹ï¼Œå°±æ˜¯æœ‰å‘æ— ç¯å›¾

**å‡ºåº¦**ï¼šä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸ºxï¼ŒæŒ‡çš„æ˜¯æœ‰xæ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹

**å…¥åº¦**ï¼šä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸ºxï¼ŒæŒ‡çš„æ˜¯æœ‰xæ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºç»ˆç‚¹

**æ— å‘å›¾**ï¼šè¾¹æ— æ–¹å‘çš„å›¾

**æ··åˆå›¾**ï¼šè¾¹å¯èƒ½æ˜¯æ— å‘çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æœ‰å‘çš„

**å¹³è¡Œè¾¹**ï¼š

- åœ¨æ— å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æ— å‘è¾¹å¦‚æœå¤šäº1æ¡ï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹ã€‚
- åœ¨æœ‰å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æœ‰å‘è¾¹å¦‚æœå¤šäº1æ¡ï¼Œå¹¶ä¸”å®ƒä»¬çš„çš„æ–¹å‘ç›¸åŒï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹

**å¤šé‡å›¾**ï¼šæœ‰å¹³è¡Œè¾¹æˆ–è€…æœ‰è‡ªç¯çš„å›¾

**ç®€å•å›¾**ï¼šæ—¢æ²¡æœ‰å¹³è¡Œè¾¹ä¹Ÿæ²¡æœ‰è‡ªç¯çš„å›¾ã€‚ 

**æœ‰æƒå›¾**ï¼šæœ‰æƒå›¾çš„è¾¹å¯ä»¥æ‹¥æœ‰æƒå€¼ï¼ˆWeightï¼‰

## æ— å‘å®Œå…¨å›¾

æ— å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨è¾¹ 

n ä¸ªé¡¶ç‚¹çš„æ— å‘å®Œå…¨å›¾æœ‰ n ( n âˆ’ 1 )/ 2 æ¡è¾¹

## æœ‰å‘å®Œå…¨å›¾

æœ‰å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨æ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹ 

n ä¸ªé¡¶ç‚¹çš„æœ‰å‘å®Œå…¨å›¾æœ‰ n ( n âˆ’ 1 ) æ¡è¾¹

ç¨ å¯†å›¾ï¼ˆDense Graphï¼‰ï¼šè¾¹æ•°æ¥è¿‘äºæˆ–ç­‰äºå®Œå…¨å›¾ 

ç¨€ç–å›¾ï¼ˆSparse Graphï¼‰ï¼šè¾¹æ•°è¿œè¿œå°‘äºå®Œå…¨å›¾

## è¿é€šå›¾

å¦‚æœé¡¶ç‚¹ x å’Œ y ä¹‹é—´å­˜åœ¨å¯ç›¸äº’æŠµè¾¾çš„è·¯å¾„ï¼ˆç›´æ¥æˆ–é—´æ¥çš„è·¯å¾„ï¼‰ï¼Œåˆ™ç§° x å’Œ y æ˜¯è¿é€šçš„

å¦‚æœæ— å‘å›¾ G ä¸­ä»»æ„2ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§°Gä¸ºè¿é€šå›¾

**è¿é€šåˆ†é‡**ï¼šæ— å‘å›¾çš„æå¤§è¿é€šå­å›¾ã€‚è¿é€šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼›éè¿é€šçš„æ— å‘å›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ 

**å¼ºè¿é€šå›¾**ï¼šå¦‚æœæœ‰å‘å›¾ G ä¸­ä»»æ„2ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§°Gä¸ºå¼ºè¿é€šå›¾

**å¼ºè¿é€šåˆ†é‡**ï¼šæœ‰å‘å›¾çš„æå¤§å¼ºè¿é€šå­å›¾ã€‚å¼ºè¿é€šå›¾åªæœ‰ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼›éå¼ºè¿é€šçš„æœ‰å‘å›¾æœ‰å¤šä¸ªå¼ºè¿é€šåˆ†é‡

## å›¾çš„å®ç°

å®ç°æ–¹æ¡ˆæœ‰ä¸¤ç§ï¼š1ã€é‚»æ¥çŸ©é˜µï¼ˆAdjacency Matrixï¼‰ï¼Œ2ã€é‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰

### é‚»æ¥çŸ©é˜µ

é‚»æ¥çŸ©é˜µçš„å­˜å‚¨æ–¹å¼ ï¼š

- ä¸€ç»´æ•°ç»„å­˜æ”¾é¡¶ç‚¹ä¿¡æ¯ 
- äºŒç»´æ•°ç»„å­˜æ”¾è¾¹ä¿¡æ¯

| é¡¶ç‚¹æ•°ç»„ |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- |
| ğœˆ0       | ğœˆ1   | ğœˆ2   | ğœˆ3   | ğœˆ4   |

| è¾¹æ•°ç»„ |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
|        | ğœˆ0   | ğœˆ1   | ğœˆ2   | ğœˆ3   | ğœˆ4   |
| ğœˆ0     | âˆ    | âˆ    | âˆ    | âˆ    | 6    |
| ğœˆ1     | 9    | âˆ    | 3    | âˆ    | âˆ    |
| ğœˆ2     | 2    | âˆ    | âˆ    | 5    | âˆ    |
| ğœˆ3     | âˆ    | âˆ    | âˆ    | âˆ    | 1    |
| ğœˆ4     | âˆ    | âˆ    | âˆ    | âˆ    | âˆ    |

é‚»æ¥çŸ©é˜µæ¯”è¾ƒé€‚åˆç¨ å¯†å›¾ ï¼Œä¸ç„¶ä¼šæ¯”è¾ƒæµªè´¹å†…å­˜

### æ¥å£è®¾è®¡

```java
public abstract int edgesSize();
public abstract int verticesSize();

public abstract void addVertex(V v);
public abstract void addEdge(V from, V to);
public abstract void addEdge(V from, V to, E weight);

public abstract void removeVertex(V v);
public abstract void removeEdge(V from, V to);
```

### é¡¶ç‚¹çš„å®šä¹‰

```java
private static class Vertex<V, E> {
	V value;
	Set<Edge<V, E>> inEdges = new HashSet<>();
	Set<Edge<V, E>> outEdges = new HashSet<>();
	Vertex(V value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		return Objects.equals(value, ((Vertex<V, E>)obj).value);
	}
	@Override
	public int hashCode() {
		return value == null ? 0 : value.hashCode();
	}
	@Override
	public String toString() {
		return value == null ? "null" : value.toString();
	}
}
```

### è¾¹çš„å®šä¹‰

```java
private static class Vertex<V, E> {
		V value;
		Set<Edge<V, E>> inEdges = new HashSet<>();
		Set<Edge<V, E>> outEdges = new HashSet<>();
		Vertex(V value) {
			this.value = value;
		}
		@Override
		public boolean equals(Object obj) {
			return Objects.equals(value, ((Vertex<V, E>)obj).value);
		}
		@Override
		public int hashCode() {
			return value == null ? 0 : value.hashCode();
		}
		@Override
		public String toString() {
			return value == null ? "null" : value.toString();
		}
	}	
```

## å›¾çš„éå†

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreadth First Searchï¼ŒBFSï¼‰ï¼Œåˆç§°ä¸ºå®½åº¦ä¼˜å…ˆæœç´¢ã€æ¨ªå‘ä¼˜å…ˆæœç´¢ã€‚äºŒå‰æ ‘çš„å±‚åºéå†

æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDepth First Searchï¼ŒDFSï¼‰ ã€‚äºŒå‰æ ‘çš„å‰åºéå†

å¹¿åº¦ä¼˜å…ˆï¼š

```
public void bfs(V begin, VertexVisitor<V> visitor) {
	if (visitor == null) return;
	Vertex<V, E> beginVertex = vertices.get(begin);
	if (beginVertex == null) return;
	
	Set<Vertex<V, E>> visitedVertices = new HashSet<>();
	Queue<Vertex<V, E>> queue = new LinkedList<>();
	queue.offer(beginVertex);
	visitedVertices.add(beginVertex);
	
	while (!queue.isEmpty()) {
		Vertex<V, E> vertex = queue.poll();
		if (visitor.visit(vertex.value)) return;
		
		for (Edge<V, E> edge : vertex.outEdges) {
			if (visitedVertices.contains(edge.to)) continue;
			queue.offer(edge.to);
			visitedVertices.add(edge.to);
		}
	}
}
```

æ·±åº¦ä¼˜å…ˆï¼š

```
// é€’å½’å®ç°
private void dfs2(Vertex<V, E> vertex, Set<Vertex<V, E>> visitedVertices) {
	System.out.println(vertex.value);
	visitedVertices.add(vertex);

	for (Edge<V, E> edge : vertex.outEdges) {
		if (visitedVertices.contains(edge.to)) continue;
		dfs2(edge.to, visitedVertices);
	}
}

// éé€’å½’å®ç°
public void dfs(V begin) {
	Vertex<V, E> beginVertex = vertices.get(begin);
	if (beginVertex == null) return;

	Set<Vertex<V, E>> visitedVertices = new HashSet<>();
	Stack<Vertex<V, E>> stack = new Stack<>();

	// å…ˆè®¿é—®èµ·ç‚¹
	stack.push(beginVertex);
	visitedVertices.add(beginVertex);
	System.out.println(beginVertex.value);

	while (!stack.isEmpty()) {
		Vertex<V, E> vertex = stack.pop();

		for (Edge<V, E> edge : vertex.outEdges) {
			if (visitedVertices.contains(edge.to)) continue;

			stack.push(edge.from);
			stack.push(edge.to);
			visitedVertices.add(edge.to);
			System.out.println(edge.to.value);

			break;
		}
	}
}
```

## AOVç½‘

ä¸€é¡¹å¤§çš„å·¥ç¨‹å¸¸è¢«åˆ†ä¸ºå¤šä¸ªå°çš„å­å·¥ç¨‹ 

å­å·¥ç¨‹ä¹‹é—´å¯èƒ½å­˜åœ¨ä¸€å®šçš„å…ˆåé¡ºåºï¼Œå³æŸäº›å­å·¥ç¨‹å¿…é¡»åœ¨å…¶ä»–çš„ä¸€äº›å­å·¥ç¨‹å®Œæˆåæ‰èƒ½å¼€å§‹

åœ¨ç°ä»£åŒ–ç®¡ç†ä¸­ï¼Œäººä»¬å¸¸ç”¨æœ‰å‘å›¾æ¥æè¿°å’Œåˆ†æä¸€é¡¹å·¥ç¨‹çš„è®¡åˆ’å’Œå®æ–½è¿‡ç¨‹ï¼Œå­å·¥ç¨‹è¢«ç§°ä¸ºæ´»åŠ¨ï¼ˆActivityï¼‰ 

ä»¥é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ã€æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ä¹‹é—´çš„å…ˆåå…³ç³»ï¼Œè¿™æ ·çš„å›¾ç®€ç§°ä¸º AOV ç½‘

æ ‡å‡†çš„AOVç½‘å¿…é¡»æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDirected Acyclic Graphï¼Œç®€ç§° DAGï¼‰

## æ‹“æ‰‘æ’åº

å‰é©±æ´»åŠ¨ï¼šæœ‰å‘è¾¹èµ·ç‚¹çš„æ´»åŠ¨ç§°ä¸ºç»ˆç‚¹çš„å‰é©±æ´»åŠ¨ ã€‚åªæœ‰å½“ä¸€ä¸ªæ´»åŠ¨çš„å‰é©±å…¨éƒ¨éƒ½å®Œæˆåï¼Œè¿™ä¸ªæ´»åŠ¨æ‰èƒ½è¿›è¡Œ

åç»§æ´»åŠ¨ï¼šæœ‰å‘è¾¹ç»ˆç‚¹çš„æ´»åŠ¨ç§°ä¸ºèµ·ç‚¹çš„åç»§æ´»åŠ¨

ä»€ä¹ˆæ˜¯æ‹“æ‰‘æ’åºï¼Ÿ å°† AOV ç½‘ä¸­æ‰€æœ‰æ´»åŠ¨æ’æˆä¸€ä¸ªåºåˆ—ï¼Œä½¿å¾—æ¯ä¸ªæ´»åŠ¨çš„å‰é©±æ´»åŠ¨éƒ½æ’åœ¨è¯¥æ´»åŠ¨çš„å‰é¢ï¼ˆç»“æœå¹¶ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼‰

### æ‹“æ‰‘æ’åº â€“ æ€è·¯ï¼š

å¯ä»¥ä½¿ç”¨å¡æ©ç®—æ³•ï¼ˆKahnäº1962å¹´æå‡ºï¼‰å®Œæˆæ‹“æ‰‘æ’åº 

- å‡è®¾ L æ˜¯å­˜æ”¾æ‹“æ‰‘æ’åºç»“æœçš„åˆ—è¡¨ 
  - â‘  æŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹æ”¾å…¥ L ä¸­ï¼Œç„¶åæŠŠè¿™äº›é¡¶ç‚¹ä»å›¾ä¸­å»æ‰ 
  - â‘¡ é‡å¤æ“ä½œ â‘ ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹ 
- å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å’Œé¡¶ç‚¹æ€»æ•°ç›¸åŒï¼Œè¯´æ˜æ‹“æ‰‘æ’åºå®Œæˆ 
- å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å°‘äºé¡¶ç‚¹æ€»æ•°ï¼Œè¯´æ˜åŸå›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº

```java
public List<V> topologicalSort() {
	List<V> list = new ArrayList<>();
	Queue<Vertex<V, E>> queue = new LinkedList<>();
	Map<Vertex<V, E>, Integer> ins = new HashMap<>();
	// åˆå§‹åŒ–ï¼ˆå°†åº¦ä¸º0çš„èŠ‚ç‚¹éƒ½æ”¾å…¥é˜Ÿåˆ—ï¼‰
	vertices.forEach((V v, Vertex<V, E> vertex) -> {
		int in = vertex.inEdges.size();
		if (in == 0) {
			queue.offer(vertex);
		} else {
			ins.put(vertex, in);
		}
	});
	
	while (!queue.isEmpty()) {
		Vertex<V, E> vertex = queue.poll();
		// æ”¾å…¥è¿”å›ç»“æœä¸­
		list.add(vertex.value);
		
		for (Edge<V, E> edge : vertex.outEdges) {
			int toIn = ins.get(edge.to) - 1;
			if (toIn == 0) {
				queue.offer(edge.to);
			} else {
				ins.put(edge.to, toIn);
			}
		}
	}
	
	return list;
}
```

## ç”Ÿæˆæ ‘ï¼ˆSpanning Treeï¼‰

ç”Ÿæˆæ ‘ï¼ˆSpanning Treeï¼‰ï¼Œä¹Ÿç§°ä¸ºæ”¯æ’‘æ ‘ 

è¿é€šå›¾çš„æå°è¿é€šå­å›¾ï¼Œå®ƒå«æœ‰å›¾ä¸­å…¨éƒ¨çš„ n ä¸ªé¡¶ç‚¹ï¼Œæ°å¥½åªæœ‰ n â€“ 1 æ¡è¾¹

### æœ€å°ç”Ÿæˆæ ‘

(Minimum Spanning Treeï¼Œç®€ç§°MST) ä¹Ÿç§°ä¸ºæœ€å°æƒé‡ç”Ÿæˆæ ‘ï¼ˆMinimum Weight Spanning Treeï¼‰ã€æœ€å°æ”¯æ’‘æ ‘

æ˜¯æ‰€æœ‰ç”Ÿæˆæ ‘ä¸­ï¼Œæ€»æƒå€¼æœ€å°çš„é‚£æ£µ ã€‚é€‚ç”¨äºæœ‰æƒçš„è¿é€šå›¾ï¼ˆæ— å‘ï¼‰

æœ€å°ç”Ÿæˆæ ‘åœ¨è®¸å¤šé¢†åŸŸéƒ½æœ‰é‡è¦çš„ä½œç”¨ï¼Œä¾‹å¦‚ è¦åœ¨ n ä¸ªåŸå¸‚ä¹‹é—´é“ºè®¾å…‰ç¼†ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥é€šä¿¡ é“ºè®¾å…‰ç¼†çš„è´¹ç”¨å¾ˆé«˜ï¼Œä¸”å„ä¸ªåŸå¸‚ä¹‹é—´å› ä¸ºè·ç¦»ä¸åŒç­‰å› ç´ ï¼Œé“ºè®¾å…‰ç¼†çš„è´¹ç”¨ä¹Ÿä¸åŒ å¦‚ä½•ä½¿é“ºè®¾å…‰ç¼†çš„æ€»è´¹ç”¨æœ€ä½ï¼Ÿ

å¦‚æœå›¾çš„æ¯ä¸€æ¡è¾¹çš„æƒå€¼éƒ½äº’ä¸ç›¸åŒï¼Œé‚£ä¹ˆæœ€å°ç”Ÿæˆæ ‘å°†åªæœ‰ä¸€ä¸ªï¼Œå¦åˆ™å¯èƒ½ä¼šæœ‰å¤šä¸ªæœ€å°ç”Ÿæˆæ ‘

æ±‚æœ€å°ç”Ÿæˆæ ‘çš„2ä¸ªç»å…¸ç®—æ³• **Prim**ï¼ˆæ™®é‡Œå§†ç®—æ³•ï¼‰ **Kruskal**ï¼ˆå…‹é²æ–¯å…‹å°”ç®—æ³•ï¼‰

## åˆ‡åˆ†å®šç†

åˆ‡åˆ†ï¼ˆCutï¼‰ï¼šæŠŠå›¾ä¸­çš„èŠ‚ç‚¹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç§°ä¸ºä¸€ä¸ªåˆ‡åˆ†

æ¨ªåˆ‡è¾¹ï¼ˆCrossing Edgeï¼‰ï¼šå¦‚æœä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œåˆ†åˆ«å±äºåˆ‡åˆ†çš„ä¸¤éƒ¨åˆ†ï¼Œè¿™ä¸ªè¾¹ç§°ä¸ºæ¨ªåˆ‡è¾¹

åˆ‡åˆ†å®šç†ï¼šç»™å®šä»»æ„åˆ‡åˆ†ï¼Œæ¨ªåˆ‡è¾¹ä¸­æƒå€¼æœ€å°çš„è¾¹å¿…ç„¶å±äºæœ€å°ç”Ÿæˆæ ‘

## Primç®—æ³•

å‡è®¾ G = (Vï¼ŒE) æ˜¯æœ‰æƒçš„è¿é€šå›¾ï¼ˆæ— å‘ï¼‰ï¼ŒA æ˜¯ G ä¸­æœ€å°ç”Ÿæˆæ ‘çš„è¾¹é›† 

ç®—æ³•ä» S = { u 0 }ï¼ˆ u 0 âˆˆ Vï¼‰ï¼ŒA = { } å¼€å§‹ï¼Œé‡å¤æ‰§è¡Œä¸‹è¿°æ“ä½œï¼Œç›´åˆ° S = V ä¸ºæ­¢

- æ‰¾åˆ°åˆ‡åˆ† C = (Sï¼ŒV â€“ S) çš„æœ€å°æ¨ªåˆ‡è¾¹ ( u 0 ï¼Œ v 0 ) å¹¶å…¥é›†åˆ Aï¼ŒåŒæ—¶å°† v 0 å¹¶å…¥é›†åˆ S

```java
private Set<EdgeInfo<V, E>> prim() {
	Iterator<Vertex<V, E>> it = vertices.values().iterator();
	if (!it.hasNext()) return null;
	Vertex<V, E> vertex = it.next();
	Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
	Set<Vertex<V, E>> addedVertices = new HashSet<>();
	addedVertices.add(vertex);
	MinHeap<Edge<V, E>> heap = new MinHeap<>(vertex.outEdges, edgeComparator);
	int verticesSize = vertices.size();
	while (!heap.isEmpty() && addedVertices.size() < verticesSize) {
		Edge<V, E> edge = heap.remove();
		if (addedVertices.contains(edge.to)) continue;
		edgeInfos.add(edge.info());
		addedVertices.add(edge.to);
		heap.addAll(edge.to.outEdges);
	}
	return edgeInfos;
}
```

## Kruskalç®—æ³•

æŒ‰ç…§è¾¹çš„æƒé‡é¡ºåºï¼ˆä»å°åˆ°å¤§ï¼‰å°†è¾¹åŠ å…¥ç”Ÿæˆæ ‘ä¸­ï¼Œç›´åˆ°ç”Ÿæˆæ ‘ä¸­å«æœ‰ V â€“ 1 æ¡è¾¹ä¸ºæ­¢ï¼ˆ V æ˜¯é¡¶ç‚¹æ•°é‡ï¼‰ 

- è‹¥åŠ å…¥è¯¥è¾¹ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯ï¼Œåˆ™ä¸åŠ å…¥è¯¥è¾¹ 
- ä»ç¬¬3æ¡è¾¹å¼€å§‹ï¼Œå¯èƒ½ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯

æ—¶é—´å¤æ‚åº¦ï¼š O (Elo g E)

```
private Set<EdgeInfo<V, E>> kruskal() {
	int edgeSize = vertices.size() - 1;
	if (edgeSize == -1) return null;
	Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
	MinHeap<Edge<V, E>> heap = new MinHeap<>(edges, edgeComparator);
	UnionFind<Vertex<V, E>> uf = new UnionFind<>();
	vertices.forEach((V v, Vertex<V, E> vertex) -> {
		uf.makeSet(vertex);
	});
	while (!heap.isEmpty() && edgeInfos.size() < edgeSize) {
		Edge<V, E> edge = heap.remove(); 
		if (uf.isSame(edge.from, edge.to)) continue; 
		edgeInfos.add(edge.info());
		uf.union(edge.from, edge.to);
	}
	return edgeInfos;
}
```

## æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰

æœ€çŸ­è·¯å¾„æ˜¯æŒ‡ä¸¤é¡¶ç‚¹ä¹‹é—´æƒå€¼ä¹‹å’Œæœ€å°çš„è·¯å¾„ï¼ˆæœ‰å‘å›¾ã€æ— å‘å›¾å‡é€‚ç”¨ï¼Œä¸èƒ½æœ‰è´Ÿæƒç¯ï¼‰

æ— æƒå›¾ç›¸å½“äºæ˜¯å…¨éƒ¨è¾¹æƒå€¼ä¸º1çš„æœ‰æƒå›¾

**æœ‰è´Ÿæƒ**è¾¹ï¼Œä½†æ²¡æœ‰è´Ÿæƒç¯æ—¶ï¼Œå­˜åœ¨æœ€çŸ­è·¯å¾„ã€‚æœ‰è´Ÿæƒç¯æ—¶ï¼Œä¸å­˜åœ¨æœ€çŸ­è·¯å¾„ã€‚å› ä¸ºè½¬ç¯å¯ä»¥æ— é™å°

æœ€çŸ­è·¯å¾„çš„å…¸å‹åº”ç”¨ä¹‹ä¸€ï¼šè·¯å¾„è§„åˆ’é—®é¢˜

æ±‚è§£æœ€çŸ­è·¯å¾„çš„3ä¸ªç»å…¸ç®—æ³• 

- å•æºæœ€çŸ­è·¯å¾„ç®—æ³• 
  - **Dijkstra**ï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼‰ 
  - **Bellman-Ford**ï¼ˆè´å°”æ›¼-ç¦ç‰¹ç®—æ³•ï¼‰
- å¤šæºæœ€çŸ­è·¯å¾„ç®—æ³• 
  - **Floyd**ï¼ˆå¼—æ´›ä¼Šå¾·ç®—æ³•ï¼‰

**æ¾å¼›æ“ä½œï¼ˆRelaxation**ï¼‰ï¼šæ›´æ–°2ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ è¿™é‡Œä¸€èˆ¬æ˜¯æŒ‡ï¼šæ›´æ–°æºç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„ æ¾å¼›æ“ä½œçš„æ„ä¹‰ï¼šå°è¯•æ‰¾å‡ºæ›´çŸ­çš„æœ€çŸ­è·¯å¾„

### Dijkstra

Dijkstra çš„åŸç†å…¶å®è·Ÿç”Ÿæ´»ä¸­çš„ä¸€äº›è‡ªç„¶ç°è±¡å®Œå…¨ä¸€æ · 

- æŠŠæ¯1ä¸ªé¡¶ç‚¹æƒ³è±¡æˆæ˜¯1å—å°çŸ³å¤´ æ¯1æ¡è¾¹æƒ³è±¡æˆæ˜¯1æ¡ç»³å­ï¼Œæ¯ä¸€æ¡ç»³å­éƒ½è¿æ¥ç€2å—å°çŸ³å¤´ï¼Œè¾¹çš„æƒå€¼å°±æ˜¯ç»³å­çš„é•¿åº¦ å°†å°çŸ³å¤´å’Œç»³å­å¹³æ”¾åœ¨ä¸€å¼ æ¡Œå­ä¸Š
- æ¥ä¸‹æ¥æƒ³è±¡ä¸€ä¸‹ï¼Œæ‰‹æ‹½ç€å°çŸ³å¤´ï¼Œæ…¢æ…¢åœ°å‘ä¸Šæèµ·æ¥ï¼Œè¿œç¦»æ¡Œé¢ï¼Œå…¶ä»–çŸ³å¤´ä¼šä¾æ¬¡è¢«æèµ·æ¥
- åç¦»å¼€æ¡Œé¢çš„å°çŸ³å¤´éƒ½æ˜¯è¢«å…ˆç¦»å¼€æ¡Œé¢çš„å°çŸ³å¤´æ‹‰èµ·æ¥çš„

### Bellman-Ford

Bellman-Ford ä¹Ÿå±äºå•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œæ”¯æŒè´Ÿæƒè¾¹ï¼Œè¿˜èƒ½æ£€æµ‹å‡ºæ˜¯å¦æœ‰è´Ÿæƒç¯

ç®—æ³•åŸç†ï¼šå¯¹æ‰€æœ‰çš„è¾¹è¿›è¡Œ V â€“ 1 æ¬¡æ¾å¼›æ“ä½œï¼ˆ V æ˜¯èŠ‚ç‚¹æ•°é‡ï¼‰ï¼Œå¾—åˆ°æ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„ 

æ—¶é—´å¤æ‚åº¦ï¼š O (EV) ï¼ŒE æ˜¯è¾¹æ•°é‡ï¼ŒV æ˜¯èŠ‚ç‚¹æ•°é‡

æœ€åæƒ…å†µæ˜¯æ°å¥½æ¯æ¬¡éƒ½ä»å³åˆ°å·¦çš„é¡ºåºå¯¹è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ 

å¯¹æ‰€æœ‰è¾¹éœ€è¿›è¡Œ V â€“ 1 æ¬¡æ¾å¼›æ“ä½œæ‰èƒ½è®¡ç®—å‡ºAåˆ°è¾¾å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„

### Floyd

Floyd å±äºå¤šæºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œèƒ½å¤Ÿæ±‚å‡ºä»»æ„2ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œæ”¯æŒè´Ÿæƒè¾¹ 

æ—¶é—´å¤æ‚åº¦ï¼š O ( V 3 ) ï¼Œæ•ˆç‡æ¯”æ‰§è¡Œ V æ¬¡ Dijkstra ç®—æ³•è¦å¥½ï¼ˆ V æ˜¯é¡¶ç‚¹æ•°é‡ï¼‰

ç®—æ³•åŸç† 

- ä»ä»»æ„é¡¶ç‚¹ i åˆ°ä»»æ„é¡¶ç‚¹ j çš„æœ€çŸ­è·¯å¾„ä¸å¤–ä¹ä¸¤ç§å¯èƒ½ 
  - â‘  ç›´æ¥ä» i åˆ° j 
  - â‘¡ ä» i ç»è¿‡è‹¥å¹²ä¸ªé¡¶ç‚¹åˆ° j 
- å‡è®¾ dist(iï¼Œj) ä¸ºé¡¶ç‚¹ i åˆ°é¡¶ç‚¹ j çš„æœ€çŸ­è·¯å¾„çš„è·ç¦» 
- å¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ kï¼Œæ£€æŸ¥ dist(iï¼Œk) + dist(kï¼Œj)ï¼œdist(iï¼Œj) æ˜¯å¦æˆç«‹ 
  - å¦‚æœæˆç«‹ï¼Œè¯æ˜ä» i åˆ° k å†åˆ° j çš„è·¯å¾„æ¯” i ç›´æ¥åˆ° j çš„è·¯å¾„çŸ­ï¼Œè®¾ç½® dist(iï¼Œj) = dist(iï¼Œk) + dist(kï¼Œj) 
  - å½“æˆ‘ä»¬éå†å®Œæ‰€æœ‰ç»“ç‚¹ kï¼Œdist(iï¼Œj) ä¸­è®°å½•çš„ä¾¿æ˜¯ i åˆ° j çš„æœ€çŸ­è·¯å¾„çš„è·ç¦»
