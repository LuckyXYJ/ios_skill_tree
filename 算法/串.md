## 串

字符串 thank 的前缀（prefix）、真前缀（proper prefix）、后缀（suffix）、真后缀（proper suffix）

| 前缀   | t, th, tha, than, thank |
| ------ | ----------------------- |
| 真前缀 | t, th, tha, than        |
| 后缀   | thank, hank, ank, nk, k |
| 真后缀 | hank, ank, nk, k        |

串匹配算法：

- 蛮力（Brute Force） 
- KMP 
- Boyer-Moore 
- Karp-Rabin 
- Sunday

## 子串位置

查找一个模式串（pattern）在文本串（text）中的位置

### 蛮力：

以字符为单位，从左到右移动模式串，直到匹配成功

swift 中没有类似Java中charAt方法，醉了，这个` text[text.index(text.startIndex, offsetBy: ti)]`真复杂

ti移动到后面，剩余位数比pattern长度小的时候可提前结束。` text.count - pi < pattern.count `

```swift
static func indexOf(text: String, pattern: String) -> Int {
    if text.count == 0 || pattern.count == 0 {
        return -1
    }    
    var ti = 0
    var pi = 0    
    while ti < text.count && pi < pattern.count {
        if text[text.index(text.startIndex, offsetBy: ti)] == pattern[pattern.index(pattern.startIndex, offsetBy: pi)] {
            ti += 1
            pi += 1
        } else {
            ti -= pi - 1
            pi = 0
        }
    }
    return pi == pattern.count ? ti - pi : -1
}
```

另外一种方法记录ti

```swift
static func indexOf2(text: String, pattern: String) -> Int {
    let tlen = text.count
    let plen = pattern.count
    if tlen == 0 || plen == 0 || tlen < plen {
        return -1
    }
    let tmax = tlen - plen
    var pi = 0
    for ti in 0...tmax {
        pi = 0
        while pi < plen {
            if text[text.index(text.startIndex, offsetBy: ti + pi)] == pattern[pattern.index(pattern.startIndex, offsetBy: pi)] {
                pi += 1
            }else {
                break
            }
        }
        if pi == plen {
            return ti
        }
    }
    return -1
}
```

