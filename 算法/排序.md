## 冒泡排序

逐个比较并移动，每次循环确定一个最大元素

```swift
static func bublleSort(arr: [Int]) -> [Int] {
    var list = arr;
    for end in (1..<list.count - 1).reversed() {
        for j in 0...end {
            if list[j] > list[j+1] {
                (list[j], list[j+1]) = (list[j+1], list[j])
            }
        }
    }
    return list
}
```

**优化1**：序列如果完全有序，可以提前终止冒泡

**优化2**：尾部有序，可以通过记录最后一次交换的位置，减少比较次数

**稳定性**：冒泡排序稳定与否，取决于判断相邻两个元素大小的的方式是` >` 或者是 ` >=`

**原地算法**：不依赖额外的资源或者依赖少数的额外资源，仅依输出来覆盖输入

## 选择排序

从待排序数组中找到最大元素的位置，并与最后面的元素交换位置。

```swift
static func sort(arr: [Int]) -> [Int] {
    if arr.count <= 1 {return arr}
    var list = arr;
    for end in (0..<list.count-1).reversed(){
        var maxIndex = 0;
        for start in 0..<end {
            if list[start] > list[maxIndex] {
                maxIndex = start;
            }
        }
        (list[maxIndex], list[end]) = (list[end], list[maxIndex])
    }
    return list
}
```

选择排序交换次数远小于冒泡排序，平均性能优于冒泡

**不稳定排序**，如数组[2 3 2 1 4]，2和1交换后，两个2的顺序便不稳定

优化：使用堆来选择最大值