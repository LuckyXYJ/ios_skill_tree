## 冒泡排序

逐个比较并移动，每次循环确定一个最大元素

**复杂度**：最好O(n)，最坏，平均复杂度O(n^2), 空间复杂度O(1)。

**稳定性**：冒泡排序稳定与否，取决于判断相邻两个元素大小的的方式是` >` 或者是 ` >=`

```swift
static func bublleSort(arr: [Int]) -> [Int] {
    var list = arr;
    for end in (1..<list.count - 1).reversed() {
        for j in 0...end {
            if list[j] > list[j+1] {
                (list[j], list[j+1]) = (list[j+1], list[j])
            }
        }
    }
    return list
}
```

**优化1**：序列如果完全有序，可以提前终止冒泡

**优化2**：尾部有序，可以通过记录最后一次交换的位置，减少比较次数

**原地算法**：不依赖额外的资源或者依赖少数的额外资源，仅依输出来覆盖输入

## 选择排序

从待排序数组中找到最大元素的位置，并与最后面的元素交换位置。

**复杂度**：最好，最坏，平均复杂度O(n^2), 空间复杂度O(1)。

**稳定性**：不稳定

```swift
static func sort(arr: [Int]) -> [Int] {
    if arr.count <= 1 {return arr}
    var list = arr;
    for end in (0..<list.count-1).reversed(){
        var maxIndex = 0;
        for start in 0..<end {
            if list[start] > list[maxIndex] {
                maxIndex = start;
            }
        }
        (list[maxIndex], list[end]) = (list[end], list[maxIndex])
    }
    return list
}
```

选择排序交换次数远小于冒泡排序，平均性能优于冒泡

**不稳定排序**，如数组[2 3 2 1 4]，2和1交换后，两个2的顺序便不稳定

优化：使用堆来选择最大值

## 堆排序

将无序的序列构建成大顶堆。

**复杂度**：最好，最坏，平均复杂度O(nlogn), 空间复杂度O(1)。

**稳定性**：不稳定

**完全二叉树**：假设根节点的编号是 i ，那么该根节点的左孩子的编号是 2i，右孩子的编号是 2i+1。

**大顶堆**：完全二叉树的根节点比其左右节点都要大

**具体步骤**：

1. 对序列进行原地建堆
2. 重复
   1. 交换堆顶元素与堆尾元素
   2. 堆元素数量减1
   3. 对0位置进行一次siftDown操作

```swift
class HeapSort: ArraySort {
    
    var list : [Int]?
    static var heapSize = 0
    
    static func sort(arr: [Int]) -> [Int] {
        if arr.count <= 1 {return arr}
        var list = arr;
        heapSize = arr.count
	      //1、构建大顶堆
        for i in (0..<heapSize>>1).reversed() {
            siftDown(arr: &list, index: i);
        }
      	//2、首尾元素交换，并重新处理首元素的位置。此时二叉堆元素数量-1
        while(heapSize > 1) {
            heapSize -= 1;
            list.swapAt(0, heapSize) // 交换二叉堆首尾元素，目的是不需要额外空间
            siftDown(arr: &list, index: 0);
        }
        return list
    }
    
    //调整大顶堆（仅是调整过程，建立在大顶堆以构建的基础上）
    static func siftDown(arr : inout [Int], index : Int){
        var tempIndex = index;
        
        let temp = arr[tempIndex];
        let half = heapSize >> 1
      
        while tempIndex < half {
            var childIndex = (tempIndex << 1)+1
            var child = arr[childIndex]
            
            let rightIndex = childIndex + 1
            
            if rightIndex < heapSize && arr[rightIndex] > child {
                
                child = arr[rightIndex];
                childIndex = rightIndex;
            }
            
            if temp > child { break }
            
            arr[tempIndex] = child;
            tempIndex = childIndex
        }
        arr[tempIndex] = temp
    }
}
```

## 插入排序

将数据分为两部分，即已排序部分，和未排序部分。逐个将未排序的的元素，插入到已排序的元素中。

**逆序对**：数组中从前往后的，大小与目的顺序相反的一对元素组成一个逆序对

**复杂度**：最好O(n)，最坏，平均复杂度O(n^2), 空间复杂度O(1)。逆序对越多，时间复杂度越高

**稳定性**：稳定

```swift
static func sort(arr: [Int]) -> [Int] {
  if arr.count < 2 {return arr}
  var list = arr
  for i in 1..<list.count {
    var index = i
    while index > 0 && list[index] < list[index - 1]{
      list.swapAt(index, index - 1)
      index -= 1
    }
  }
  return list
}
```

优化1：将交换转为挪动

1. 备份待插入元素temp
2. 头部有序数据中比temp大的，往右边挪动一个位置
3. 将temp插入到最终合适的位置

```swift
static func sort(arr: [Int]) -> [Int] {
  if arr.count < 2 {return arr}
  var list = arr
  for i in 1..<list.count {
    var index = i
    let temp = list[index];
    while index > 0 && temp < list[index - 1]{
      list[index] = list[index - 1]
      index -= 1
    }
    list[index] = temp
  }
  return list
}
```

优化2：二分查找

```swift
class InsertionSort2: ArraySort {
    
    static func sort(arr: [Int]) -> [Int] {
        if arr.count < 2 {return arr}
        var list = arr
        for i in 1..<list.count {
            let dest = InsertionSort2.search(arr: list, index: i)
            InsertionSort2.insert(arr: &list, source: i, dest: dest)
        }
        return list
    }
    
    static func insert(arr: inout [Int], source: Int, dest: Int) {
        
        if dest == source { return }
        let temp = arr[source];
        for i in ((dest+1)...source).reversed() {
            arr[i] = arr[i - 1];
        }
        arr[dest] = temp
    }
 
    static func search(arr: [Int], index: Int) -> Int {
        var begin = 0
        var end = index
        
        while(begin < end) {
            let mid = (begin + end) >> 1
            if (arr[mid] > arr[index]) {
                end = mid
            } else {
                begin = mid + 1
            }
        }
        return begin
    }
}
```

