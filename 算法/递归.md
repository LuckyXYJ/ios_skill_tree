## 递归

把规模大的问题递归规模较小的同类型问题，小到一定程度可以得出结果

递归调用的空间复杂度 = 递归深度 * 每次调用所需的辅助空间

**递归套路**：

1. 明确函数的功能 
   1. 先不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的，能完成什么功能？
2. 明确原问题与子问题的关系 
   1. 寻找 f(n) 与 f(n – 1) 的关系
3. 明确递归基（边界条件） 
   1. 递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解 
   2. 寻找递归基，相当于是思考：问题规模小到什么程度可以直接得出解？

**典型例子**：斐波那契数列

F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n≥3）

递归计算空间复杂度O(n)

递归调用的过程中，会将每一次调用的**参数**、**局部变量**都保存在了对应的栈帧（Stack Frame）中，会导致栈溢出。

**递归转非递归**：

1. 自己维护一个栈，来保存参数、局部变量，空间复杂度不变
2. 重复使用一组相同的变量来保存每个栈帧的内容，空间复杂度O(n)降到了O(1)

## 尾调用

**尾调用**：一个函数的最后一个动作是调用函数 

如果最后一个动作是调用自身，称为**尾递归**（Tail Recursion），是尾调用的特殊情况

一些编译器能对尾调用进行优化，以达到节省栈空间的目的

**尾调用优化**也叫做尾调用消除（Tail Call Elimination） 

- 如果当前栈帧上的局部变量等内容都不需要用了，当前栈帧经过适当的改变后可以直接当作被尾调用的函数的栈帧使用，然后程序可以 jump 到被尾调用的函数代码
- 生成栈帧改变代码与 jump 的过程称作尾调用消除或尾调用优化
- 尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高

消除尾递归里的尾调用比消除一般的尾调用容易很多

- 比如Java虚拟机（JVM）会消除尾递归里的尾调用，但不会消除一般的尾调用（因为改变不了栈帧） 
- 因此尾递归优化相对比较普遍，平时的递归代码可以考虑尽量使用尾递归的形式

### 举例

```c++
OS_NOINLINE void A(void) {
  static int a = 0;
  a++;
  B();
}

OS_NOINLINE void B(void) {
  static int b = 0;
  b++;
}
```

A 的汇编

```Apache
XSQRuntimeDemo`A:
  0x10212f508 <+0>: adrp  x8, 7
  0x10212f50c <+4>: ldr  w9, [x8, #0x968]
  0x10212f510 <+8>: add  w9, w9, #0x1       ; =0x1 
  0x10212f514 <+12>: str  w9, [x8, #0x968]
  0x10212f518 <+16>: b   0x10212f51c        ; B at ViewController.m:396:6
```

这里对 B 的调用，使用了 `b` 指令，而不是函数调用的 `bl` 指令。

### 如何规避

在一些抓栈的场景，有时候我们需要在编译前准确数出调用栈的个数，因此需要规避尾调用优化带来的影响。

#### OS_NOT_TAIL_CALLED

```c++
OS_NOINLINE void A(void) {
  static int a = 0;
  a++;
  B();
}

OS_NOINLINE OS_NOT_TAIL_CALLED void B(void) {
  static int b = 0;
  b++;
}
```

相当于 https://clang.llvm.org/docs/AttributeReference.html#not-tail-called

#### os_prevent_tail_call_optimization();

```c++
OS_NOINLINE void A(void) {
  static int a = 0;
  a++;
  B();
  os_prevent_tail_call_optimization();
}

OS_NOINLINE void B(void) {
  static int b = 0;
  b++;
}
```
