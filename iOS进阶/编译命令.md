## 创建静态库

```
libtool -static -arch_only x86_64 a.o -o a.a

libtool -static -arch_only arm64 -D -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.plat form/Developer/SDKs/iPhoneOS13.6.sdk test.o -o libTest.a
```

## 创建动态库

```
clang -dynamiclib -target arm64-apple-ios13.5 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhon eOS.platform/Developer/SDKs/iPhoneOS13.6.sdk a.o -o a.dylib
```

## ar命令

`ar`压缩目标文件，并对其进行编号和索引，形成静态库。同时也可以解压缩静态库，查看有哪些目标文件：

 ar -rc a.a a.o

- -r: 像a.a添加or替换文件  
- -c: 不输出任何信息
- -t: 列出包含的目标文件

## 合并静态库

```
libtool -static -o <OUTPUT NAME> <LIBRARY_1> <LIBRARY_2>
```

## 操作1：链接静态库.a生成可执行文件

操作文件夹：链接静态库.a文件

在生成test.o文件时，需要有TestExample.h文件

clang 命令参数：

```
clang命令参数：
     -x: 指定编译文件语言类型
     -g: 生成调试信息
     -c: 生成目标文件，只运行preprocess，compile，assemble，不链接
     -o: 输出文件
     -isysroot: 使用的SDK路径
     1. -I<directory> 在指定目录寻找头文件 header search path
     2. -L<dir> 指定库文件路径（.a\.dylib库文件） library search path
     3. -l<library_name> 指定链接的库文件名称（.a\.dylib库文件）other link flags -lAFNetworking
     -F<directory> 在指定目录寻找framework framework search path
     -framework <framework_name> 指定链接的framework名称 other link flags -framework AFNetworking
     
```

### 1、将test.m编译成test.o:

1. 使用OC
2. 生成的是X86_*64*_macOS架构的代码    
   1. Big Sur是：x86_64-apple-macos11.1，
   2. 之前是：x86_64-apple-macos10.15
3. 使用ARC
4. 使用的SDK的路径在:
   1. Big Sur是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk
   2. 之前是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.15.sdk
5. 用到的其他库的头文件地址在./Frameworks

```sh
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./StaticLibrary \
-c test.m -o test.o
```

将TestExample.m 编译成TestExample.o

```sh
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-c TestExample.m -o TestExample.o
```

### 2、.o文件生成.a静态库

创建库命令，可以创建动态静态库

使用上面生成的TestExample.o 来创建libTestExample.a 静态库

```
libtool -static -arch_only x86_64 TestExample.o -o libTestExample.a
```

### 3、.o文件链接静态库，生成可执行文件

test.o链接libTestExample.a生成test可执行文件

-L./StaticLibrary 在当前目录的子目录StaticLibrary查找需要的库文件

-lTestExample 链接的名称为libTestExample/TestExample的动态库或者静态库

查找规则：先找lib+<library_name>的动态库，找不到，再去找lib+<library_name>的静态库，还找不到，就报错

-syslibroot: 系统库文件的目录

```sh
ld \
-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -lsystem -framework Foundation \
-lTestExample \
-L./StaticLibrary \
test.o -o test
```

也可以使用**clang**

```
clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./StaticLibrary \
-lTestExample \
test.o -o test
```

## 操作2：链接Frameworks静态库

文件夹：静态库与Framework

### 1、创建.frameworks静态库

执行命令 TestExample.m --> TestExample.o --> TestExample文件

```
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-c TestExample.m -o TestExample.o

libtool -static -arch_only x86_64 TestExample.o -o TestExample
```

将TestExample文件和Header文件夹放在一个文件夹内，修改名字为TestExample.framework

### 2、test.m 生成 test.o

```
clang -x objective-c  \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./Frameworks/TestExample.framework/Headers \
-c test.m -o test.o
```

### 3、test.o生成可执行文件

test.o链接TestExample.framework生成test可执行文件

-F./Frameworks 在当前目录的子目录Frameworks查找需要的库文件

-framework TestExample 链接的名称为TestExample.framework的动态库或者静态库

查找规则：先找TestExample.framework的动态库，找不到，再去找TestExample.framework的静态库，还找不到，就报错

```
clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-F./Frameworks \
-framework TestExample \
test.o -o test
```

## 操作3：链接动态库.dylib生成可执行文件

### 1、将.m文件编译生成.o文件

将test.m编译成test.o:

```
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./dylib \
-c test.m -o test.o
```

将TestExample.m 编译成TestExample.o

```
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-c TestExample.m -o TestExample.o
```

### 2、.o文件生成dylib动态库文件

```
clang -dynamiclib \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
TestExample.o -o libTestExample.dylib
```

### 3、.o文件链接动态库，生成可执行文件

```
clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./dylib \
-lTestExample \
test.o -o test
```

此时生成的test可执行文件无法执行，因为找不到动态库

### 4、尝试操作，还是不行

```
libtool -static -arch_only x86_64 TestExample.o -o libTestExample.a

ld -dylib -arch x86_64 \
-macosx_version_min 11.1 \
-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-lsystem -framework Foundation \
-ObjC \
libTestExample.a -o libTestExample.dylib

clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./dylib \
-lTestExample \
test.o -o test
```

##### 5、寻找问题原因

使用otool 命令查看test文件mach-header信息

```
otool -l test | grep 'dylib' -A 3 -i
```

![image-20221208105102189](http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20221208105102189.png)

从上图发现libTestExample.dylib与别的动态库区别是没有路径。

继续使用otool命令查看libTestExample.dylib文件

```
otool -l libTestExample.dylib | grep 'LC_ID_DYLIB' -A 5
```

![image-20221208110048659](http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20221208110048659.png)

从这里的name可以看出，问题出现在动态库身上

可以之生成dylib文件时加入 -install_name来解决这问题

### 6、修改dylib文件install_name，或者在生成dylib文件时指定 install_name

```
install_name_tool -id /Users/xyj/Documents/GitHub/ios_skill_tree/iOS进阶/动静态库原理/链接动态库.dylib文件/dylib/libTestExample.dylib libTestExample.dylib


ld -dylib -arch x86_64 \
-macosx_version_min 11.1 \
-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-lsystem -framework Foundation \
-ObjC \
-install_name  /Users/xyj/Documents/GitHub/ios_skill_tree/iOS进阶/动静态库原理/链接动态库.dylib文件/dylib/libTestExample.dylib \
libTestExample.a -o libTestExample.dylib
```

### 7、重新生成test可执行文件，执行文件

此时能够成功执行文件，但是存在问题是，上一步指定路径是固定路径，换个路径就不行了

使用RPATH对其进行优化

```
install_name_tool -id @rpath/dylib/libTestExample.dylib libTestExample.dylib

install_name_tool -add_rpath /Users/xyj/Documents/GitHub/ios_skill_tree/iOS进阶/动静态库原理/链接动态库.dylib文件 test
```

以上给test添加rpath为绝对路径，依然无法移动文件。可以使用executable_path进行优化

```
install_name_tool -add_rpath @executable_path  test
```



