## 模块化

模块化开发最终的目的是将程序划分成一个个小的结构； 

这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构； 

这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用； 

也可以通过某种方式，导入另外结构中的变量、函数、对象等；

ES6（2015）之前JS自身没有模块化，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等；

## CommonJS

每一个js文件都是一个单独的模块；这个模块中包括CommonJS规范的核心变量：exports、module.exports、require；我们可以使用这些变量来方便的进行模块化开发；

模块化的核心是导出和导入：

- exports和module.exports可以负责对模块中的内容进行导出； 
- require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；

### require细节

require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。

导入格式如下：require(X)

查找规则如下

1. X是一个Node核心模块，比如path、http
   1. 直接返回核心模块，并且停止查找
2. X是以 ./ 或 ../ 或 /（根目录）开头的。将X当做一个文件在对应的目录下查找；
   1. 如果有后缀名，按照后缀名的格式查找对应的文件 
   2. 如果没有后缀名，会按照如下顺序： 
      1. 直接查找文件X 
      2. 查找X.js文件 
      3. 查找X.json文件 
      4. 查找X.node文件
   3. 没有找到对应的文件，将X作为一个目录
      1. 查找目录下面的index文件 
         1. 查找X/index.js文件
         2. 查找X/index.json文件 
         3. 查找X/index.node文件
   4. 如果没有找到，那么报错：not found
3. 直接是一个X（没有路径），并且X不是一个核心模块
   1. 从该require所在文件夹往上，逐级查找node_modules
   2. 如果到根路径中都没有找到，那么报错：not found

### CommonJS规范缺点

CommonJS加载模块是同步的。

只有等到对应的模块加载完毕，当前模块中的内容才能被运行；

解决：目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；

## 模块的加载过程

模块在被第一次引入时，模块中的js代码会被运行一次

模块被多次引入时，会缓存，最终只加载（运行）一次

如果有循环引入，那么加载顺序是按深度优先顺序开始加载

## ES Module

ES Module模块采用export和import关键字来实现模块化：export负责将模块内的内容导出； import负责从其他模块导入内容；

采用ES Module将自动采用严格模式：use strict

ES Module和CommonJS的模块化有一些不同之处：

- 一方面它使用了import和export关键字； 
- 另一方面它采用编译期的静态分析，并且也加入了动态引用的方式；

### exports关键字

export关键字将一个模块中的变量、函数、类等导出；

我们希望将其他中内容全部导出，它可以有如下的方式： 

1. 在语句声明的前面直接加上export关键字 
2. 将所有需要导出的标识符，放到export后面的 {}中
   1. 注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的；
   2. 所以： export {name: name}，是错误的写法； 
3. 导出时给标识符起一个别名

### import关键字

import关键字负责从另外一个模块中导入内容

导入内容的方式也有多种： 

1. import {标识符列表} from '模块'； 
   1. 注意：这里的{}也不是一个对象，里面只是存放导入的标识符列表内容； 
2. 导入时给标识符起别名 
3. 通过 * 将模块功能放到一个模块功能对象（a module object）上

### export和import结合使用

```
export { add as addNums } from './math.js'
```

为什么要这样做呢？

- 在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中； 
- 这样方便指定统一的接口规范，也方便阅读； 
- 这个时候，我们就可以使用export和import结合使用；

### default用法

默认导出（default export）

- 默认导出export时可以不需要指定名字； 
- 在导入时不需要使用 {}，并且可以自己来指定名字； 
- 它也方便我们和现有的CommonJS等规范相互操作；

注意：在一个模块中，只能有一个默认导出（default export）；

### import函数

通过import加载一个模块，是不可以在其放到逻辑代码中的

如果根据不懂的条件，动态来选择加载模块的路径； 这个时候我们需要使用 import() 函数来动态加载；

### import meta

import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。

它包含了这个模块的信息，比如说这个模块的URL； 

在ES11（ES2020）中新增的特性；

### ES Module的解析流程

ES Module的解析过程可以划分为三个阶段：

1. 构建（Construction），根据地址查找js文件，并且下载，将其解析成模块记录（Module Record）； 
2. 实例化（Instantiation），对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向 对应的内存地址。 
3. 运行（Evaluation），运行代码，计算值，并且将值填充到内存地址中；