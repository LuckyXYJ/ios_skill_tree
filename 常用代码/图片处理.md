## 修改图片颜色

将UIImage中的非透明部分统一修改成黑色：

Objective-C实现

```objective-c
- (UIImage *)convertImageToBlack:(UIImage *)image {
    // 获取UIImage的像素数据，并转换成可编辑的CGImageRef对象。
    CGImageRef imageRef = [image CGImage];
    NSUInteger width = CGImageGetWidth(imageRef);
    NSUInteger height = CGImageGetHeight(imageRef);

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    unsigned char *rawData = (unsigned char*)calloc(height * width * 4, sizeof(unsigned char));
    NSUInteger bytesPerPixel = 4;
    NSUInteger bytesPerRow = bytesPerPixel * width;
    NSUInteger bitsPerComponent = 8;
    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);

    /*
     遍历像素，将不透明的像素值修改为黑色。透明度值小于等于127的像素将被视为透明像素。
     */
    NSInteger red,green,blue,alpha;
    for (int x=0; x<width; x++) {
        for (int y=0; y<height; y++) {
            NSInteger byteIndex = (bytesPerRow * y) + x * bytesPerPixel;
            red = rawData[byteIndex];
            green = rawData[byteIndex + 1];
            blue = rawData[byteIndex + 2];
            alpha = rawData[byteIndex + 3];
            if (alpha > 127) {
                rawData[byteIndex] = 0; // 修改红色像素为黑色
                rawData[byteIndex + 1] = 0; // 修改绿色像素为黑色
                rawData[byteIndex + 2] = 0; // 修改蓝色像素为黑色
            }
        }
    }

    // 生成新的UIImage。
    CGImageRef newCGImage = CGBitmapContextCreateImage(context);
    UIImage *newImage = [UIImage imageWithCGImage:newCGImage];
    CGContextRelease(context);
    CGImageRelease(newCGImage);
    CGColorSpaceRelease(colorSpace);
    free(rawData);
    
    return newImage;
}
```

swift实现

```swift
func convertImageToBlack(_ image: UIImage) -> UIImage? {
    //获取UIImage的像素数据，并转换成可编辑的CGImage对象
    guard let imageRef = image.cgImage,
          let colorSpace = imageRef.colorSpace,
          let context = CGContext(data: nil, width: Int(imageRef.width), height: Int(imageRef.height), bitsPerComponent: 8, bytesPerRow: Int(imageRef.width) * 4, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue),
          let rawData = context.data?.assumingMemoryBound(to: UInt8.self) else {
        return nil
    }
    context.draw(imageRef, in: CGRect(x: 0, y: 0, width: imageRef.width, height: imageRef.height))
    
    /*
     遍历像素，将不透明的像素值修改为黑色。透明度值小于等于127的像素将被视为透明像素。
     */
    var byteIndex: Int
    let bytesPerPixel = 4
    let bytesPerRow = bytesPerPixel * Int(imageRef.width)
    for y in 0..<Int(imageRef.height) {
        for x in 0..<Int(imageRef.width) {
            byteIndex = y * bytesPerRow + x * bytesPerPixel
            let alpha = Int(rawData[byteIndex + 3])
            if alpha > 127 {
                rawData[byteIndex] = 0 // 修改红色像素为黑色
                rawData[byteIndex + 1] = 0 // 修改绿色像素为黑色
                rawData[byteIndex + 2] = 0 // 修改蓝色像素为黑色
            }
        }
    }
  
    // 生成新的UIImage
    guard let newCGImage = context.makeImage() else {
        return nil
    }

    let newImage = UIImage(cgImage: newCGImage, scale: image.scale, orientation: image.imageOrientation)
    return newImage
}
```

## 两个图片合并 

> 来自chatgpt

在 iOS 中将两个图片合成为一个图片可以使用 Core Graphics 框架中的 CGContext 进行绘制。下面是具体的步骤。

1. 创建一个画布，使用 UIGraphicsBeginImageContextWithOptions 函数来创建一个大小合适的画布。

```
UIGraphicsBeginImageContextWithOptions(size, NO, 0.0);
```

2. 在画布上绘制第一个图片。可以使用 drawInRect 方法来绘制，也可以使用 CGContextDrawImage 函数来绘制。

```
[image1 drawInRect:CGRectMake(0, 0, size.width, size.height)];
```

3. 在画布上绘制第二个图片。同样可以使用 drawInRect 方法或 CGContextDrawImage 函数来绘制。

```
[image2 drawInRect:CGRectMake(0, 0, size.width, size.height)];
```

4. 合成图片并返回。使用 UIGraphicsGetImageFromCurrentImageContext 函数来获取最终的合成图片。

```
UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext();
```

5. 结束画布绘制。使用 UIGraphicsEndImageContext 函数来结束画布绘制。

```
UIGraphicsEndImageContext();
```

完整的代码示例：

```objc
CGSize size = CGSizeMake(width, height);
UIGraphicsBeginImageContextWithOptions(size, NO, 0.0);

[image1 drawInRect:CGRectMake(0, 0, size.width, size.height)];
[image2 drawInRect:CGRectMake(0, 0, size.width, size.height)];

UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext();

UIGraphicsEndImageContext();
```

使用Swift实现合并两张图片的代码：

```swift
func mergeImages(firstImage: UIImage, secondImage: UIImage) -> UIImage? {
    let imageSize = CGSize(width: firstImage.size.width, height: firstImage.size.height)
    UIGraphicsBeginImageContextWithOptions(imageSize, false, 0.0)
    
    firstImage.draw(in: CGRect(origin: CGPoint.zero, size: imageSize))
    secondImage.draw(in: CGRect(origin: CGPoint.zero, size: imageSize))
    
    let mergedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    
    return mergedImage
}
```

在上面的代码中，我们首先创建了一个和第一张图片一样大小的画布。接着，我们把第一张图片绘制到画布上，再把第二张图片绘制到同一个画布上。最后，我们获取合并之后的图片并将画布绘制结束。

使用时，只需要调用该函数即可，例如：

```swift
let firstImage = UIImage(named: "firstImage")
let secondImage = UIImage(named: "secondImage")
let mergedImage = mergeImages(firstImage: firstImage!, secondImage: secondImage!)
```

注意：在使用的时候一定要确保两张图片的大小是相同的，否则合并后的效果可能不理想。
