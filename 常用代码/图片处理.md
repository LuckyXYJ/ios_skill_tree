## 修改图片颜色

将UIImage中的非透明部分统一修改成黑色：

Objective-C实现

```objective-c
- (UIImage *)convertImageToBlack:(UIImage *)image {
    // 获取UIImage的像素数据，并转换成可编辑的CGImageRef对象。
    CGImageRef imageRef = [image CGImage];
    NSUInteger width = CGImageGetWidth(imageRef);
    NSUInteger height = CGImageGetHeight(imageRef);

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    unsigned char *rawData = (unsigned char*)calloc(height * width * 4, sizeof(unsigned char));
    NSUInteger bytesPerPixel = 4;
    NSUInteger bytesPerRow = bytesPerPixel * width;
    NSUInteger bitsPerComponent = 8;
    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);

    /*
     遍历像素，将不透明的像素值修改为黑色。透明度值小于等于127的像素将被视为透明像素。
     */
    NSInteger red,green,blue,alpha;
    for (int x=0; x<width; x++) {
        for (int y=0; y<height; y++) {
            NSInteger byteIndex = (bytesPerRow * y) + x * bytesPerPixel;
            red = rawData[byteIndex];
            green = rawData[byteIndex + 1];
            blue = rawData[byteIndex + 2];
            alpha = rawData[byteIndex + 3];
            if (alpha > 127) {
                rawData[byteIndex] = 0; // 修改红色像素为黑色
                rawData[byteIndex + 1] = 0; // 修改绿色像素为黑色
                rawData[byteIndex + 2] = 0; // 修改蓝色像素为黑色
            }
        }
    }

    // 生成新的UIImage。
    CGImageRef newCGImage = CGBitmapContextCreateImage(context);
    UIImage *newImage = [UIImage imageWithCGImage:newCGImage];
    CGContextRelease(context);
    CGImageRelease(newCGImage);
    CGColorSpaceRelease(colorSpace);
    free(rawData);
    
    return newImage;
}
```

swift实现

```swift
func convertImageToBlack(_ image: UIImage) -> UIImage? {
    //获取UIImage的像素数据，并转换成可编辑的CGImage对象
    guard let imageRef = image.cgImage,
          let colorSpace = imageRef.colorSpace,
          let context = CGContext(data: nil, width: Int(imageRef.width), height: Int(imageRef.height), bitsPerComponent: 8, bytesPerRow: Int(imageRef.width) * 4, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue),
          let rawData = context.data?.assumingMemoryBound(to: UInt8.self) else {
        return nil
    }
    context.draw(imageRef, in: CGRect(x: 0, y: 0, width: imageRef.width, height: imageRef.height))
    
    /*
     遍历像素，将不透明的像素值修改为黑色。透明度值小于等于127的像素将被视为透明像素。
     */
    var byteIndex: Int
    let bytesPerPixel = 4
    let bytesPerRow = bytesPerPixel * Int(imageRef.width)
    for y in 0..<Int(imageRef.height) {
        for x in 0..<Int(imageRef.width) {
            byteIndex = y * bytesPerRow + x * bytesPerPixel
            let alpha = Int(rawData[byteIndex + 3])
            if alpha > 127 {
                rawData[byteIndex] = 0 // 修改红色像素为黑色
                rawData[byteIndex + 1] = 0 // 修改绿色像素为黑色
                rawData[byteIndex + 2] = 0 // 修改蓝色像素为黑色
            }
        }
    }
  
    // 生成新的UIImage
    guard let newCGImage = context.makeImage() else {
        return nil
    }

    let newImage = UIImage(cgImage: newCGImage, scale: image.scale, orientation: image.imageOrientation)
    return newImage
}
```

